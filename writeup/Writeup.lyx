#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass extarticle
\begin_preamble
\usepackage{hyperref}
\usepackage[strings]{underscore}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "Heuristica"
\font_sans "default" "Cantarell"
\font_typewriter "default" "Ubuntu Mono"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine biblatex
\cite_engine_type numerical
\biblio_style plain
\biblio_options sorting=none
\biblatex_bibstyle numeric
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 5
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Engineering EPQ - indoor navigation
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Meta
\end_layout

\begin_layout Subsection
Activity log (incl.
 Gantt charts)
\end_layout

\begin_layout Standard

\emph on
Use this to record the progress of your project.
 You may want to discuss:
\end_layout

\begin_layout Standard

\emph on
• What you have done (eg from one week to the next)
\end_layout

\begin_layout Standard

\emph on
• (if you are working in a group), what discussions you have had
\end_layout

\begin_layout Standard

\emph on
• Any changes that you have (or will need) to make to your plans
\end_layout

\begin_layout Standard

\emph on
• What resources you have found/hope to find
\end_layout

\begin_layout Standard

\emph on
• What problems you are encountering and how you are solving them
\end_layout

\begin_layout Standard

\emph on
• What you are going to do next
\end_layout

\begin_layout Subsubsection
2018-09-20 (pre-project planning)
\end_layout

\begin_layout Standard
Before I started work on the project writeup, design and implementation,
 I set about defining what project I'd like to do, and wrote up the Project
 Proposal Form (PPF), with this information.
 In order to decide, I wrote up proposals for four different potential problems
 to solve, discussing my ideas with the Engineering staff at my school and
 my tutor-assessor (TA) in order to decide which one I might like to tackle
 for my EPQ.
 In order to keep my project manageable, my TA advised me to keep my project
 reasonably narrowly-defined, aiming to clearly identify and narrow down
 a specific issue to tackle, instead of aiming to solve an inachievably
 large problem.
 I also spent some time working on planning how I would use my time throughout
 the duration of the project, using GanttProject software to produce an
 initial Gantt chart (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:gantt-v1"
plural "false"
caps "false"
noprefix "false"

\end_inset

), for later reference.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Gantt chart - original.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The initial GanttProject-generated Gantt chart for the entire project, showing
 milestones, tasks and dates on the left, with a graphical representation
 on the right.
\begin_inset CommandInset label
LatexCommand label
name "fig:gantt-v1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
2018-10-29
\end_layout

\begin_layout Standard
Despite having planned my time out before the project, I found that I hadn't
 made much headway in the first few weeks of the project - I had explored
 a few non-specific articles, but I hadn't really managed to put pen to
 paper.
 I discussed this with my TA, who agreed that I would produce a series of
 research presentations, presenting my findings every week to the Engineering
 staff and the other EPQ students, in order to help me stick to my deadlines.
\end_layout

\begin_layout Standard
Using this framework, I started researching how to determine the user's
 current location, given that it was the first item on my PPF.
 I first looked at examples of prior art (e.g.
 the COEX deployment mentioned in the research section), using this to guide
 my research into what specific technologies were used - for example, some
 papers about WiFi and FM-based localization, as well as the FootPath paper
 and a paper that used camera phones.
 I found the WiFi k-nearest-neighbours approach mentioned in one of the
 papers to be quite hard to understand, and wanted to investigate it and
 the FootPath implementation further.
\end_layout

\begin_layout Standard
Generally, I found the framework set by my TA to be very helpful in organizing
 myself, so I pledged to continue to use it for the remainder of the research
 section.
\end_layout

\begin_layout Standard

\emph on
Action items set for next week
\end_layout

\begin_layout Itemize
Investigate the WiFi k-nearest-neighbours mathematics, and see how hard
 it is to understand/implement
\end_layout

\begin_layout Itemize
Investigate the FootPath algorithms, and how hard the maths behind it is
 to understand
\end_layout

\begin_layout Itemize
Progress toward a sample implementation of some of these methods
\end_layout

\begin_layout Subsubsection
2018-11-05
\end_layout

\begin_layout Standard
I found the FootPath algorithm to be the most interesting approach to investigat
e, so I researched the maths behind their Best Fit implementation, which
 turned out not to be too hard to understand.
 In addition, I wrote a sample implementation of this algorithm in Rust
 (the language I'm most familiar with), to verify my understanding.
 Some initial testing with some fabricated values seemed to show the implementat
ion working - it rejected wildly incorrect values, whilst continuing to
 report progress if the readings were close enough to the correct values.
\end_layout

\begin_layout Standard
Following on from the ease of implementation of FootPath, I didn't think
 it was necessary to investigate WiFi that much further, although I did
 follow up on the action item and looked up a quick summary of how k-nearest-nei
ghbours works.
 The FootPath paper had provided some initial reasons why WiFi-based localizatio
n may have been too costly, so I decided to look into this further, as well
 as pursuing other aspects of my PPF.
\end_layout

\begin_layout Standard

\emph on
Action items set for next week
\end_layout

\begin_layout Itemize
Start researching mobile application frameworks in earnest, in order to
 make progress toward testing
\end_layout

\begin_layout Itemize
Look for more evidence to make a decision between FootPath and WiFi
\end_layout

\begin_layout Itemize
Look into graph-search algorithms, for A to B navigation.
\end_layout

\begin_layout Subsubsection
2018-11-12
\end_layout

\begin_layout Standard
This week, I mainly focused on researching mobile application frameworks,
 and unfortunately didn't have that much time to research the other action
 items.
 This involved a combination of looking through traditional literature (which
 was mostly outdated, i.e.
 2015 and earlier), and looking online for more up-to-date, but less academic,
 information.
\end_layout

\begin_layout Standard
My research narrowed the options down for mobile application frameworks
 to React Native and Cordova, so I decided that I'd need to try and work
 towards implementation on using both of these frameworks in order to test
 which one would be the best to use.
\end_layout

\begin_layout Standard
I also took the time to re-evaluate my time planning, aiming to make a new
 Gantt chart by next week.
 To account for the change, I considered the fact that indoor localization
 & mobile app framework finding were probably two of the most important
 PPF points, given that graph searching/navigation wasn't anticipated to
 take much time at all, due to its relatively low complexity.
 Therefore, a new Gantt chart was required, to incorporate this information.
\end_layout

\begin_layout Standard

\emph on
Action items for next week
\end_layout

\begin_layout Itemize
Investigate steps required to get accelerometer, compass, and WiFi scanning
 working on both mobile platforms
\end_layout

\begin_layout Itemize
Make a new, or altered, Gantt chart
\end_layout

\begin_layout Subsubsection
2018-11-19
\end_layout

\begin_layout Standard
This week, I took the time to update my Gantt chart (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:gantt-v2"
plural "false"
caps "false"
noprefix "false"

\end_inset

), removing time allocated to research real-time sensing (which I deemed
 to be out of scope for this EPQ: making such a system could be another
 project in and of itself) and to preliminary implementations, in order
 to make more time for researching mobile app frameworks and localization.
 In doing so, I noticed that the old Gantt chart was rather vague, and took
 steps to rectify this.
\end_layout

\begin_layout Standard
I also looked into comparing React Native and Cordova, as mentioned in last
 week's action items, and, in doing so, found out that WiFi localization
 would in fact not be possible (it's not allowed on iOS), causing me to
 direct my research away from it.
\end_layout

\begin_layout Standard

\emph on
Action items for next week
\end_layout

\begin_layout Itemize
Research different graph-search algorithms
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/eeeeeta/engineering-epq/gantt/Gantt chart - revision 2.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The second revision of the Gantt chart, with a more realistic and focused
 research time planning section.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:gantt-v2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
2018-11-19
\end_layout

\begin_layout Standard
This week, I researched different graph-search algorithms for use in my
 project, drawing on both literature and prior experience from implementing
 Djikstra's algorithm in an earlier project of mine.
 As planned, this didn't take that long, given my prior knowledge, although
 I did make sure to justify my choice of algorithm through proper research.
\end_layout

\begin_layout Standard

\emph on
Action items for next week
\end_layout

\begin_layout Itemize
Do more research on localization methods
\end_layout

\begin_layout Subsubsection
2018-11-26
\end_layout

\begin_layout Standard
In order to flesh out my research on accelerometer-based localization, I
 conducted more research into this field - finding, for example, the CompAcc
 paper, which was a precursor to the FootPath system that I looked at earlier.
 I also looked at other completely different methods for localization, such
 as the Scape AI/computer vision system, to make my research yet more detailed.
\end_layout

\begin_layout Standard
For next week, as planned on the Gantt chart, I decided to start writing
 up my research into a formal report; previously, all research had been
 summarized in the form of weekly research presentations.
 This was also required in order to meet the school's deadlines for the
 literature section of the final EPQ.
\end_layout

\begin_layout Standard

\emph on
Action items for next week
\end_layout

\begin_layout Itemize
Convert the research presentations into a formal report
\end_layout

\begin_layout Subsubsection
2018-12-03
\end_layout

\begin_layout Standard
This week was mainly focused on writing up the research report, which involved
 investigating BibTeX, in order to add references to my writeup (written
 using LyX and LaTeX).
 I found that Google Scholar had an automatic BibTeX reference generator,
 which greatly helped this task.
\end_layout

\begin_layout Standard
Looking at my Gantt chart, the next stage of the project was working toward
 some initial designs and implementations.
 However, I found this stage to be inadequately planned, so I resolved to
 make a more detailed plan of what needed to be done in the way of implementatio
n.
 In addition, the original Gantt chart assumed that I wouldn't take any
 break for the Christmas holidays - however, feeling suitably burned out
 from a hard term's work, I decided that this would probably be unworkable.
\end_layout

\begin_layout Standard
In terms of sticking to the Gantt chart more generally, though, I believed
 that I was mostly on track; the research section had been completed and
 written up on time, which was promising for the rest of the project.
\end_layout

\begin_layout Standard

\emph on
At this point, I took a break for the Christmas holidays.
\end_layout

\begin_layout Standard

\emph on
Action items for after the holidays
\end_layout

\begin_layout Itemize
Make a new Gantt chart to plan the design stages
\end_layout

\begin_layout Itemize
Work toward initial designs and implementations
\end_layout

\begin_layout Subsubsection
2019-01-07
\end_layout

\begin_layout Standard
In order to focus my efforts in the upcoming term, I updated my Gantt chart
 to reflect my actual progress - namely, the fact that I'd taken a break
 from the project during the Christmas holidays.
 I also planned out the stages in front of me with regards to actually designing
 the project - while the previous Gantt chart simply mentioned 
\begin_inset Quotes eld
\end_inset

implement final design
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

write final design
\begin_inset Quotes erd
\end_inset

 as action items, the updated version (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:gantt-v3"
plural "false"
caps "false"
noprefix "false"

\end_inset

) broke these steps down into concrete, actionable parts of the project
 to work on.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/eeeeeta/engineering-epq/gantt/2019-version.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The third revision of the Gantt chart, updated to account for time out during
 the holidays.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:gantt-v3"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
2019-01-14
\end_layout

\begin_layout Subsubsection
2019-01-21
\end_layout

\begin_layout Subsubsection
2019-01-28
\end_layout

\begin_layout Subsubsection
2019-02-03
\end_layout

\begin_layout Subsubsection
2019-02-11
\end_layout

\begin_layout Subsubsection
2019-02-18
\end_layout

\begin_layout Subsubsection
2019-02-25
\end_layout

\begin_layout Subsubsection
2019-03-01
\end_layout

\begin_layout Subsubsection
2019-03-06
\end_layout

\begin_layout Subsubsection
2019-03-13
\end_layout

\begin_layout Subsubsection
2019-03-20
\end_layout

\begin_layout Section
Research
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
The Project Proposal Form (PPF) for this EPQ identified four main research
 areas to be covered:
\end_layout

\begin_layout Itemize
How to determine the user's current location inside a building (where GPS
 and other methods are generally infeasible);
\end_layout

\begin_layout Itemize
Which methods to use for A-B turn-by-turn navigation, based on the relative
 efficiencies of each method;
\end_layout

\begin_layout Itemize
How to provide accurate time estimation;
\end_layout

\begin_layout Itemize
Which framework to use to develop mobile applications for iOS and Android.
\end_layout

\begin_layout Standard
Over the course of the planned research time, each of these five PPF research
 areas was explored, with the results summarized below.
 
\end_layout

\begin_layout Subsection
Localization methods
\end_layout

\begin_layout Standard
When investigating this area of research, it was helpful to investigate
 what other methods had already been used to solve the problem of indoor
 localization.
 It immediately becomes apparent that GPS, the more 'standard' way to determine
 a user's location, does not work very well indoors, at least using the
 GPS receivers present in standard smartphones 
\begin_inset CommandInset citation
LatexCommand cite
key "kjaergaard2010indoor"
literal "false"

\end_inset

 - the cited paper states that 
\begin_inset Quotes eld
\end_inset

it has been a fact that GPS performs too poorly inside buildings to provide
 usable indoor positioning
\begin_inset Quotes erd
\end_inset

, showing examples of how it can be made to work 
\begin_inset Quotes eld
\end_inset

using state-of-the-art receivers
\begin_inset Quotes erd
\end_inset

, although agreeing that 
\begin_inset Quotes eld
\end_inset

receivers embedded in mobile phones...provided considerably lower availability,
 lower accuracy, and longer time to first fix
\begin_inset Quotes erd
\end_inset

.
 Indeed, a quick verification of this fact using the GPS receiver in my
 personal smartphone whilst indoors reveals utterly unworkable performance,
 with zero satellites identified even after one minute of searching.
 Therefore, other methods for indoor localization were investigated, as
 GPS seemed unlikely to work.
\end_layout

\begin_layout Standard
Many researchers aimed to provide localization by adding beacons to the
 environment, such as the Drishti indoor/outdoor system 
\begin_inset CommandInset citation
LatexCommand cite
key "ran2004drishti"
literal "false"

\end_inset

, which used an 
\begin_inset Quotes eld
\end_inset

OEM ultrasound system
\begin_inset Quotes erd
\end_inset

 to locate the user.
 Another paper aimed to provide pedestrian indoor navigation by using RFID
 tags embedded in various places around the environment, and by using a
 sensor in the user's foot to scan them 
\begin_inset CommandInset citation
LatexCommand cite
key "ruiz2012accurate"
literal "false"

\end_inset

.
 While these approaches are a valid way to perform indoor navigation, they
 would not be useful in this particular case; the project aims to provide
 indoor navigation in areas such as schools, where significant changes to
 the environment cannot be made.
 Adding beacons or equipment to the environment would defeat this purpose,
 adding extra cost and complexity to the deployment of the system.
 A more low-cost and less permanent approach may still be viable - for example,
 one paper used posters stuck up on walls around the building with codes
 for users to scan 
\begin_inset CommandInset citation
LatexCommand cite
key "mulloni2009indoor"
literal "false"

\end_inset

, which could still be useful for this project's purpose.
\end_layout

\begin_layout Standard
However, there are other ways to perform localization that do not require
 changes to the environment.
 One paper 
\begin_inset CommandInset citation
LatexCommand cite
key "han2014building"
literal "false"

\end_inset

 provided an example of a WiFi-based
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
WiFi may also be referred to as 'WLAN' throughout the course of this writeup.
\end_layout

\end_inset

 localization system deployed at the COEX complex in Seoul, Korea in 2010.
 Another paper proposed a system called FootPath 
\begin_inset CommandInset citation
LatexCommand cite
key "link2011footpath"
literal "false"

\end_inset

, which purported to provide accurate indoor navigation using only the accelerom
eter present in every smartphone.
 In addition to these more established and researched techniques, new startup
 companies such as Scape 
\begin_inset CommandInset citation
LatexCommand cite
key "ScapeIo"
literal "false"

\end_inset

 also provide inspiration in the form of 
\begin_inset Quotes eld
\end_inset

hyper-accurate location powered by computer vision
\begin_inset Quotes erd
\end_inset

 - i.e.
 they use AI and computer vision technologies to determine location based
 on landmarks, demonstrating that they have successfully developed this
 technology for alpha access in London only.
\end_layout

\begin_layout Standard
Based on these examples, more detailed research into specific methodologies
 for indoor localization was conducted.
\end_layout

\begin_layout Subsubsection
WiFi-based
\end_layout

\begin_layout Standard
The COEX deployment 
\begin_inset CommandInset citation
LatexCommand cite
key "han2014building"
literal "false"

\end_inset

 provides a good example of a complete Wi-Fi based navigation system that
 had 
\begin_inset Quotes eld
\end_inset

more than 200,000 users
\begin_inset Quotes erd
\end_inset

 download the system in its first day of use.
 The paper provides a good high-level overview of what technologies were
 used (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:coex-overview"
plural "false"
caps "false"
noprefix "false"

\end_inset

): performing an evaluation of access points in the area and design goals
 (1, 2), drawing a map of the indoor area and determing fingerprint measurement
 locations (3), WiFi Radio Map (WRM) construction (4), and system programming,
 testing, and evaluation (5, 6, 7).
 This provides a good structure that this project could potentially follow,
 if WiFi-based navigation were to be used.
 Indeed, this basic outline is corroborated by other research, with a paper
 surveying WLAN fingerprinting methods 
\begin_inset CommandInset citation
LatexCommand cite
key "honkavirta2009comparative"
literal "false"

\end_inset

 also stating that 
\begin_inset Quotes eld
\end_inset

the location of the user is determined by comparing obtained RSSI values
 to a radio map
\begin_inset Quotes erd
\end_inset

, where the radio map consists of 
\begin_inset Quotes eld
\end_inset

measured RSSI patterns at certain locations
\begin_inset Quotes erd
\end_inset

 - a similar idea to what the COEX paper was suggesting, stating that 
\begin_inset Quotes eld
\end_inset

collecting precise WiFi fingerprints at each marked measure point...[is] critical
 for accurate localization
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename indoor_navigation_outline.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A diagrammatic representation of steps taken to create the COEX system.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:coex-overview"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "han2014building"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The COEX paper states that they 
\begin_inset Quotes eld
\end_inset

adopted the k-weighted nearest neighbours (kWNN, k = 3) for [their] localization
 engine
\begin_inset Quotes erd
\end_inset

, as well as a 
\begin_inset Quotes eld
\end_inset

signal filter, adaptive Kalman filter, and a delay filter
\begin_inset Quotes erd
\end_inset

 in order to 
\begin_inset Quotes eld
\end_inset

further improve accuracy
\begin_inset Quotes erd
\end_inset

.
 Other papers also reference the 
\begin_inset Quotes eld
\end_inset

k-weighted nearest neighbours
\begin_inset Quotes erd
\end_inset

 approach, with a paper on indoor localization using FM radio signals 
\begin_inset CommandInset citation
LatexCommand cite
key "moghtadaiee2011indoor"
literal "false"

\end_inset

 (which wasn't about WiFi specifically, but followed a similar methodology)
 naming it as a possible methodology to use for positioning, while the comparati
ve survey mentioned earlier 
\begin_inset CommandInset citation
LatexCommand cite
key "honkavirta2009comparative"
literal "false"

\end_inset

 also featured an evaluation of the kWNN method.
\end_layout

\begin_layout Standard
It therefore was apparent that the kWNN method would be a reasonable first
 step when designing a WiFi-based localization system, especially given
 its successful use in the COEX complex.
 However, further research into potential WiFi-based localization methodologies
 was not conducted; for reasons that will soon be explained, WiFi was determined
 to be inferior for this product's usecase.
\end_layout

\begin_layout Subsubsection
Accelerometer-based
\end_layout

\begin_layout Standard
Although WiFi-based localization is a popular method for performing localization
, it is not without its downsides (as will soon be explained).
 An alternative method for performing indoor localization comes in the form
 of accelerometer-based solutions, analzying the accelerometer and compass
 present in every modern smartphone to figure out their relative movement
 from a known starting point, or along a known path.
\end_layout

\begin_layout Standard
A prominent example of this method was presented by Constandache et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "constandache2010towards"
literal "false"

\end_inset

 in their paper 
\begin_inset Quotes eld
\end_inset

Towards Mobile Phone Localization without War-Driving
\begin_inset Quotes erd
\end_inset

, which, as suggested by the title, makes the case that war-driving (i.e.
 performing a survey of WiFi access points in an area to construct a WiFi
 radio map, as explained in the last section), is 
\begin_inset Quotes eld
\end_inset

an expensive calibration operation
\begin_inset Quotes erd
\end_inset

 that still leaves 
\begin_inset Quotes eld
\end_inset

a large portion of space...uncovered
\begin_inset Quotes erd
\end_inset

 in applications such as outdoor GPS-free localization.
 Instead, they present a scheme called 
\emph on
CompAcc
\emph default
 that augments GPS with accelerometer data, 
\begin_inset Quotes eld
\end_inset

matching the directional trail
\begin_inset Quotes erd
\end_inset

 it can derive from the accelerometer 
\begin_inset Quotes eld
\end_inset

with possible walking paths around the phone's known location
\begin_inset Quotes erd
\end_inset

.
 However, it acknowledges that 
\begin_inset Quotes eld
\end_inset

in certain scenarios, the difference between the estimated and the actual
 location can cause confusion
\begin_inset Quotes erd
\end_inset

, especially since 
\begin_inset Quotes eld
\end_inset

electronic compasses and accelerometers are highly noisy
\begin_inset Quotes erd
\end_inset

, requiring the algorithm to fall back on AGPS for localization every now
 and again to check that the error has not grown too large.
\end_layout

\begin_layout Standard
Link et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "link2011footpath"
literal "false"

\end_inset

 propose a possible extension of this methodology, promising to similarly
 
\begin_inset Quotes eld
\end_inset

accurately localize a user on [their] route...using only the accelerometer
 and compass readily available in modern smartphones
\begin_inset Quotes erd
\end_inset

.
 Critically, this implementation does 
\emph on
not
\emph default
 provide for localization in general - they only 
\begin_inset Quotes eld
\end_inset

solve the localization problem on a specified route
\begin_inset Quotes erd
\end_inset

 - limiting the applicability of such a method, as it would not be harder
 to dynamically reroute if the user strayed from the expected path.
 The FootPath paper states that 
\begin_inset Quotes eld
\end_inset

our path matching...is more robust by handling source to destination routes
 in their entirety
\begin_inset Quotes erd
\end_inset

 - presenting this characteristic as positive, and a possible cause of increased
 accuracy, while the original CompAcc paper constantly re-evaluates the
 user's possible route based on smaller route segments.
\end_layout

\begin_layout Standard
An overview of the FootPath methodology is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:footpath-overview"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (taken from the paper), which shows how the system obtains map material
 (1) and takes input from the user (2) to determine the current position
 and end position, and thus a route between the two.
 Once this is determined, the system breaks the route down into individual
 steps and uses accelerometer data to correlate the users' movement (4,
 5), so that the user is presented with a live map screen showing their
 progress along the route (6).
 The most interesting parts, for this project's usecase, are items (4) and
 (5) - how to 
\begin_inset Quotes eld
\end_inset

match [the user's] steps onto the map
\begin_inset Quotes erd
\end_inset

, and how, indeed, to obtain step data from a phone's accelerometer.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename footpath_overview.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A diagrammatic overview of the FootPath system.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:footpath-overview"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "link2011footpath"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Step detection, according to the FootPath paper, can be done as 
\begin_inset Quotes eld
\end_inset

accelerometer values...display a characteristic regular pattern
\begin_inset Quotes erd
\end_inset

, stating that steps can be detected by 
\begin_inset Quotes eld
\end_inset

apply[in]g a low pass filter
\begin_inset Quotes erd
\end_inset

 and then detecting a step 
\begin_inset Quotes eld
\end_inset

whenever the acceleration value falls by at least 
\begin_inset ERT
status open

\begin_layout Plain Layout

$p = 2 
\backslash
frac{m}{s^2}$
\end_layout

\end_inset

 within a window 
\begin_inset ERT
status open

\begin_layout Plain Layout

$w$
\end_layout

\end_inset

 of 5 consecutive samples, or 165ms
\begin_inset Quotes erd
\end_inset

.
 The CompAcc paper is unfortunately somewhat vaguer about how it accomplished
 this, mentioning only 
\begin_inset Quotes eld
\end_inset

a rhythmic acceleration-signature in human walking patterns
\begin_inset Quotes erd
\end_inset

, but cautioning that 
\begin_inset Quotes eld
\end_inset

several factors [relating to phone accelerometers] cause fluctuations in
 [measured] acceleration, resulting in erroneous displacements
\begin_inset Quotes erd
\end_inset

.
 The exemplary data provided in the FootPath paper (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:footpath-exemplary-data"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which correlated with the shape of the CompAcc data, as well as the fact
 that the CompAcc paper cited an location accuracy of less than 11m, provided
 some justification to show that step detection might indeed be possible
 via these methods.
 However, further testing during the design an implementation phase would
 most likely be necessary to decide whether this method would actually be
 feasible.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Exemplary accelerometer raw data and detected steps, as taken from the FootPath
 paper.
 The upper plot depicts raw data from the phone's sensor, while the bottom
 plot marks on instances of detected steps.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:footpath-exemplary-data"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "link2011footpath"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second area of interest in the FootPath paper - matching steps to expected
 steps - was accomplished via 
\begin_inset Quotes eld
\end_inset

two strategies...
 (1) First Fit and (2) Best Fit
\begin_inset Quotes erd
\end_inset

.
 First Fit enjoys the advantage of being qualitatively somewhat easier to
 implement and understand, given that its description is mostly in understandabl
e plain English and is relatively simple as an algorithm (whereas Best Fit
 requires a more high-level understanding of matrices and the 
\begin_inset ERT
status open

\begin_layout Plain Layout

$argmin$
\end_layout

\end_inset

 function).
 However, since the paper's evaluation section mentioned how 
\begin_inset Quotes eld
\end_inset

we have an average accuary 
\emph on
[sic]
\emph default
 of 1.6m for Best Fit and 5.6m for First Fit
\begin_inset Quotes erd
\end_inset

, and how 
\begin_inset Quotes eld
\end_inset

[Best Fit] performs better and more stable 
\emph on
[sic]
\emph default
 than First Fit
\begin_inset Quotes erd
\end_inset

, it was decided that Best Fit would be the best fit for this project, provided
 the additional complexity did not hamper implementation.
\end_layout

\begin_layout Standard
In order to validate this judgement in the research phase, an initial test
 implementation of the Best Fit algorithm was conducted (see Appendix 
\emph on
[fixme: insert source code and reference!]
\emph default
), testing both how easy it is to understand correctly, and whether it performs
 as desired.
 A quick test case, as seen in the example source code, shows it mostly
 behaving as expected - rejecting readings that are wildly different to
 their expected orientations, whilst registering progress for readings that
 match up within some error range.
 Therefore, the Best Fit algorithm was shown to be the most ideal choice
 for the project, provided it worked with actual test data once it was possible
 to obtain some.
\end_layout

\begin_layout Subsubsection
Comparison and evaluation
\end_layout

\begin_layout Standard
The FootPath paper also provides a good high-level overview of the different
 indoor localization technologies available, dividing them into 
\begin_inset Quotes eld
\end_inset

lateration, fingerprinting, and dead reckoning
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "link2011footpath"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
Lateration methods include GPS and other beacon-related technologies, which,
 as previously discussed, would prove impractical for this project - indeed,
 the paper states that 
\begin_inset Quotes eld
\end_inset

they require very carefully placed transmitters and an exact calibration,
 making wide public deployment impractical
\begin_inset Quotes erd
\end_inset

.
 GPS and other methods also, according to the CompAcc paper, 
\begin_inset Quotes eld
\end_inset

pose a serious tradeoff between localization accuracy and energy
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "constandache2010towards"
literal "false"

\end_inset

, with Constandache et al.
 having shown in another paper about energy-efficient GPS 
\begin_inset CommandInset citation
LatexCommand cite
key "constandache2009enloc"
literal "false"

\end_inset

 that 
\begin_inset Quotes eld
\end_inset

GPS...incurs a serious energy cost that can drain a fully-charged phone battery
 in 8.5 hours
\begin_inset Quotes erd
\end_inset

.
 In summary, then, it is defniitely the case that beacon technologies would
 be either too energy-consuming or simply unworkable to be used.
\end_layout

\begin_layout Standard
Fingerprinting methods 
\begin_inset Quotes eld
\end_inset

collect the identities and signal strengths of the WiFi access points in
 the vicinity
\begin_inset Quotes erd
\end_inset

, as has already been shown.
 However, as the FootPath paper states, 
\begin_inset Quotes eld
\end_inset

this calibration...is time-consuming, and easily becomes invalidated when physical
 conditions change
\begin_inset Quotes erd
\end_inset

, echoing the CompAcc paper's claims that 
\begin_inset Quotes eld
\end_inset

war-driving is an expensive calibration operation
\begin_inset Quotes erd
\end_inset

.
 This raises questions related to the amount of time available for the project;
 it seems unlikely that there would be time to perform this calibration
 at different areas around a building for evaluation, and there would always
 be the risk of all the work being useless, if the WiFi access points in
 the building were to change.
 In addition, there also is the drawback of the need for 
\begin_inset Quotes eld
\end_inset

an adequate number of access points in the vicinity
\begin_inset Quotes erd
\end_inset

, which is 
\begin_inset Quotes eld
\end_inset

problematic in protected environments like historic buildings
\begin_inset Quotes erd
\end_inset

.
 This is echoed by the COEX paper, which emphasised the necessity of 
\begin_inset Quotes eld
\end_inset

analyzing the access point environment in a target indoor area
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "han2014building"
literal "false"

\end_inset

 before deployment, stating that 
\begin_inset Quotes eld
\end_inset

if necessary, additional APs should be installed in...subareas lacking strong
 AP signals
\begin_inset Quotes erd
\end_inset

.
 Therefore, it seems clear that a WiFi-based localization approach would
 be rather convoluted, and perhaps unsuited to this particular project,
 especially given the cost associated with generating a radio map.
\end_layout

\begin_layout Standard
Dead reckoning methods, such as FootPath and CompAcc, 
\begin_inset Quotes eld
\end_inset

are based on detecting steps and step headings
\begin_inset Quotes erd
\end_inset

, but often have the problem that 
\begin_inset Quotes eld
\end_inset

errors accumulate quickly
\begin_inset Quotes erd
\end_inset

.
 The FootPath authors claim that 
\begin_inset Quotes eld
\end_inset

[their] approach can reset these errors by matching the steps using sequence
 alignment
\begin_inset Quotes erd
\end_inset

, a claim that likely would require some experimental evidence to assess
 its validity.
 In addition, the dead reckoning method proposed by FootPath requires knowledge
 of the path the user is going to take in order to function, which may reduce
 usability.
\end_layout

\begin_layout Standard
In addition, it might also be possible to incorporate aspects of the camera-phon
e based localization system 
\begin_inset CommandInset citation
LatexCommand cite
key "mulloni2009indoor"
literal "false"

\end_inset

 - for example, sticking posters up with scannable codes could help solve
 some of the issues with users getting lost and being unable to localize
 themselves via FootPath.
 However, such considerations will be discussed further at the design stage.
\end_layout

\begin_layout Subsection
Mobile application frameworks
\end_layout

\begin_layout Standard
It immediately becomes apparent that this project requires the building
 of some form of smartphone application in order to most effectively complete
 its job; there is no other way to provide indoor navigation to users without
 purchasing or manufacturing other equipment, since most of the users targeted
 by the product already own smartphones.
 However, the issue of how to go about doing so is an important one that
 necessitated research in order to come to a reasoned judgement.
\end_layout

\begin_layout Subsubsection
A note on research recency
\end_layout

\begin_layout Standard
In contrast to the fast-moving world of modern software engineering, most
 of the literature available on mobile application development is rather
 old (i.e.
 older than 2015).
 Indeed, it would be quite challenging to find reliable modern research,
 as credibility depends on the literature having time to be criticised and
 peer-reviewed.
 It still nevertheless has some utility, but it is prudent to consider the
 age of the research when evaluating its applicability – specific toolsets
 and programming styles mentioned may be very old indeed, but it may well
 be the case that more general statements about the field still hold some
 weight.
\end_layout

\begin_layout Subsubsection
Characterisation
\end_layout

\begin_layout Standard
Broadly, mobile application frameworks can be separated out into 
\emph on
native
\emph default
 development approaches, which entail writing platform-specific apps using
 the tooling provided for each mobile platform (e.g.
 Xcode for iOS / Android Studio for Android), and 
\emph on
cross-platform
\emph default
 development approaches, which use a framework to enable the development
 of apps that can be written once to work on both platforms.
 In fact, cross-platform approaches can be further separated into web, hybrid,
 interpreted, and generated methodologies 
\begin_inset CommandInset citation
LatexCommand cite
key "xanthopoulos2013comparative"
literal "false"

\end_inset

.
 Native apps 
\begin_inset Quotes eld
\end_inset

provide the richest user experience
\begin_inset Quotes erd
\end_inset

, as the developer is able to use the tools designed specifically for the
 native platform, adapting their app to use familiar design elements and
 patterns.
 However, developing two native applications for the two major mobile platforms
 obviously requires quite a lot of time, necessitating the use of a cross-platfo
rm framework for this project – after all, 
\begin_inset Quotes eld
\end_inset

a major requirement of developers is the ability to target as many platforms
 as possible with the least amount of effort
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "ohrt2012cross"
literal "false"

\end_inset

, according to a paper examining cross-platform tools written in 2012.
\end_layout

\begin_layout Standard
Choosing a hybrid framework is thus an important task, as multiple exist
 that could be suited to the project's usecase.
 Using the classification proposed earlier, it is necessary to decide between
 web, hybrid, interpreted, and generated, weighing up the advantages and
 disadvantages of each method (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:xplatform-dev-table"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename apps_taxonomy.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A comparative analysis of cross-platform development approaches.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:xplatform-dev-table"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "xanthopoulos2013comparative"
literal "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The web approach involves building web apps, 
\begin_inset Quotes eld
\end_inset

browser-based applications in which the software is downloaded from the
 web
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "xanthopoulos2013comparative"
literal "false"

\end_inset

 - bringing with them the significant disadvantages of being unusable when
 the user is offline, incurring extra time penalties needed for rendering
 the web pages, and suffering from limited access to the underlying hardware.
 Qualitatively, it is evident that web applications provide a very poor
 user experience; one need only attempt to use one on a mobile phone in
 order to see why.
 This perceived ugliness is often due to the fact that web applications
 must 
\emph on
simulate 
\emph default
native UI controls in order to look like other native applications, as they
 cannot render these elements themselves.
 However, they are significantly easier to develop than native mobile applicatio
ns in many cases, due to the familiarity of developers with web tooling.
\end_layout

\begin_layout Standard
Hybrid apps 
\begin_inset Quotes eld
\end_inset

try to combine the advantages of web and native apps
\begin_inset Quotes erd
\end_inset

 - essentially embedding a webview into an application, allowing the web
 application to access more of the mobile platform's APIs whilst providing
 little improvement in the way of user experience, which still has to be
 simulated, but provides less of a barrier to developers wanting to use
 most of the capabilities available on a platform whilst developing using
 familiar web tooling.
\end_layout

\begin_layout Standard
Intepreted apps are apps where 
\begin_inset Quotes eld
\end_inset

native code is automatically generated to implement the user interface
\begin_inset Quotes erd
\end_inset

 - that is, apps where developers can program in whatever language offered
 by the interpreted application framework (usually languages like Ruby,
 Python, etc.
 which are useful outside of mobile application development), and benefit
 from a native user interface.
 However, users are often tied to the framework used - 
\begin_inset Quotes eld
\end_inset

new platform-specific features can be available to apps only when...supported
 by the development environment
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Generated apps are similar, but involve generating entirely separate application
s comprised entirely of native code, based on some defined specification.
 It was determined that this category can be effectively ignored; the paper
 referencing it failed to provide any concrete examples of such a framework,
 and the methodology appeared roughly identical to the interpreted classificatio
n anyway.
\end_layout

\begin_layout Standard
It is therefore evident that hybrid and interpreted methodologies are most
 promising for this project's use-case, as both provide access to the low-level
 platform APIs that would be required for the project (e.g.
 accelerometer, WiFi information).
 However, the question remains as to which framework in particular should
 be used.
\end_layout

\begin_layout Subsubsection
React Native and Apache Cordova
\end_layout

\begin_layout Standard
The two prevailing frameworks used for mobile application development that
 research identified were Apache Cordova and React Native 
\emph on
[fixme: we definitely need a citation for this]
\emph default
.
 Indeed, a paper published in 2015 stated that Cordova was the most frequently
 used cross-platform development framework 
\begin_inset CommandInset citation
LatexCommand cite
key "malavolta2015hybrid"
literal "false"

\end_inset

, with the disused 
\emph on
[citation?]
\emph default
 Appcelerator Titanium coming in second.
 Cordova's website states that it allows developers to make 
\begin_inset Quotes eld
\end_inset

mobile apps with HTML, CSS & JS
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Cordova"
literal "false"

\end_inset

, enabling them to 
\begin_inset Quotes eld
\end_inset

target multiple platforms with one code base
\begin_inset Quotes erd
\end_inset

 - classifying it as a hybrid development approach, using the classification
 system previously discussed.
 Indeed, its website and branding appears to advertise many of the same
 attributes as identified earlier; with 
\begin_inset Quotes eld
\end_inset

reusable code across platforms
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

support for offline scenarios
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

access [to] native device APIs
\begin_inset Quotes erd
\end_inset

 being identified as its three main selling points.
 Cordova also appears to be used by multiple other frameworks - such as
 Adobe PhoneGap and the Ionic Framework, which both build on Cordova to
 provide a more coherent mobile application development strategy.
\end_layout

\begin_layout Standard
In contrast, the more recently developed React Native is an interpreted
 framework, advertising that 
\begin_inset Quotes eld
\end_inset

with React Native, you don't build a 
\begin_inset Quotes eld
\end_inset

mobile web app
\begin_inset Quotes erd
\end_inset

, an 
\begin_inset Quotes eld
\end_inset

HTML5 app
\begin_inset Quotes erd
\end_inset

 or a 
\begin_inset Quotes eld
\end_inset

hybrid app
\begin_inset Quotes erd
\end_inset


\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "ReactNative"
literal "false"

\end_inset

 - stating instead that 
\begin_inset Quotes eld
\end_inset

you build a real mobile app that's indistinguishable from an app built using
 Objective-C or Java.
 This is, again, a reiteration of the 
\begin_inset Quotes eld
\end_inset

interpreted
\begin_inset Quotes erd
\end_inset

 class of development strategies, as React Native uses native UI components
 (the website says 
\begin_inset Quotes eld
\end_inset

the same fundamental UI building blocks as regular iOS and Android apps
\begin_inset Quotes erd
\end_inset

) to provide the frontend, with JavaScript and React (a JS framework for
 UI design) providing the code behind the UI components.
\end_layout

\begin_layout Subsubsection
Evaluation and comparison
\end_layout

\begin_layout Standard
Cordova might seem like a more promising choice, on the surface - given
 that it has research backing its use, and has been around for longer than
 React Native.
 In addition, React Native mandates that the application be designed using
 the model-view-controller (MVC) paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "leff2001web"
literal "false"

\end_inset

 employed in React
\emph on
 -
\emph default
 which might have a tendency to increase developer friction and lock the
 developer in to using the React framework, while Cordova allows development
 using standard HTML5 tooling and APIs.
 However, React Native seems like a very popular choice in the app development
 world of 2018 - originally created and managed by Facebook, it is used
 not only in Facebook's own applications, Facebook and Instagram, but also
 in applications such as Skype, Uber, Bloomberg, and Tesla, as evidenced
 by their website showcase 
\begin_inset CommandInset citation
LatexCommand cite
key "ReactNative"
literal "false"

\end_inset

.
 Cordova, on the other hand, features a smorgasbord of applications that
 are relatively unpopular and obscure, bringing its utility for modern developme
nt into question.
\end_layout

\begin_layout Standard
However, this analysis is mostly qualitative, and cannot be relied upon
 to make a more definite judgement.
 Therefore, further investigation into how to use each framework was conducted,
 with the result that Cordova was almost immediately discounted, leaving
 React Native as the more favourable option.
 The methodology for this was as follows: given that accelerometer use might
 well be required for the project - indeed, it would be a good thing to
 use to test a mobile application framework, as well as validating the FootPath
 algorithm's efficacy - an attempt was made to create an application featuring
 accelerometer usage in each framework, by way of evaluation.
\end_layout

\begin_layout Standard
Cordova almost immediately demonstrated its inadequacy in this field; its
 official documentation on the accelerometer API, as featured prominently
 in a Google search for 
\begin_inset Quotes eld
\end_inset

cordova accelerometer
\begin_inset Quotes erd
\end_inset

, states that the documentation linked to is out of date 
\begin_inset CommandInset citation
LatexCommand cite
key "CordovaFail"
literal "false"

\end_inset

, providing a link to the latest version - in which the accelerometer API
 seems to have vanished entirely, given that the API is listed as deprecated
 
\begin_inset CommandInset citation
LatexCommand cite
key "CordovaDeprecated"
literal "false"

\end_inset

.
 Another option is provided in the form of 
\family typewriter
cordova-plugin-device-motion
\family default
, a Cordova plugin also prominently featured on Google that also has deficient
 documentation: it states that 
\begin_inset Quotes eld
\end_inset

with the W3C Device Motion and Orientation API now being supported...this plugin
 is not needed anymore
\begin_inset Quotes erd
\end_inset

.
 However, this Device Motion API also seems outdated: the version linked
 to by the documentation 
\begin_inset CommandInset citation
LatexCommand cite
key "DeviceOrientationInitial"
literal "false"

\end_inset

 states that it is old, while the latest version has a very large 
\begin_inset Quotes eld
\end_inset

Beware.
 This specification is no longer in active maintenance and the Geolocation
 Working Group does not intend to maintain it further
\begin_inset Quotes erd
\end_inset

 notice 
\begin_inset CommandInset citation
LatexCommand cite
key "DeviceOrientationLatest"
literal "false"

\end_inset

.
 Given that all of the documentation and tooling related to basic accelerometer
 usage seems outdated or marked as deprecated, it is immediately evident
 that Cordova would be a suboptimal choice.
\end_layout

\begin_layout Standard
This is further strengthened by how React Native performs in this test -
 with the prominent Google results being not only an actively maintained
 accelerometer/sensors library, 
\family typewriter
react-native-sensors
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "RnSensors"
literal "false"

\end_inset

 (with its last commit on 2018-12-04 as of the time of writing, demonstrating
 its actively maintained state), which features multiple projects actively
 using it, together with examples for how to use it - but also an introductory
 blog post that introduces developers to the library, acquainting them with
 its design decisions and giving a general overview 
\begin_inset CommandInset citation
LatexCommand cite
key "RnSensorsTutorial"
literal "false"

\end_inset

.
 It thus follows that React Native seems to have the most active community
 of developers around it (as well as applications depending on it), and
 seems to be in active use - making it the better choice for this project.
\end_layout

\begin_layout Subsubsection
Relation to localization methods
\end_layout

\begin_layout Standard
Throughout the course of research, it also became apparent that WiFi-based
 localization would not work at all, given that iOS, one of the most prominent
 mobile operating systems that the project would need to support, does not
 provide any APIs for general-purpose WiFi scanning at all.
 Indeed, an Apple Technical Q&A confirms the fact that 
\begin_inset Quotes eld
\end_inset

iOS does not have a general purpose API for WiFi scanning and configuration
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "AppleQAWiFi"
literal "false"

\end_inset

.
 Although this technical Q&A is marked as outdated, it is apparent that
 this still holds true - no apps in the App Store seem to have this capability
 (whereas, for Android, a number of 
\begin_inset Quotes eld
\end_inset

WiFi analyzer
\begin_inset Quotes erd
\end_inset

 applications are offered in the Play Store that scan for nearby WiFi networks),
 and no libraries available for React Native support this capability on
 iOS (both libraries evaluated during research 
\begin_inset CommandInset citation
LatexCommand cite
key "RnDroidWifi"
literal "false"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "RnWifiBis"
literal "false"

\end_inset

 either do not support iOS or only support 
\emph on
connecting
\emph default
 to WiFi networks, not scanning for them).
 Therefore, it is yet more unlikely that WiFi based localization could be
 used by this project.
\end_layout

\begin_layout Subsection
Turn-by-turn navigation
\end_layout

\begin_layout Subsubsection
Overview
\end_layout

\begin_layout Standard
To provide accurate, effective turn-by-turn navigation, the project will
 require an algorithm for finding the shortest path between two locations
 in a building, so that the app can guide the user along this path.
 This is commonly done by using a 
\emph on
graph
\emph default
 data structure - an example being Project OSRM (Open Source Routing Machine)
 
\begin_inset CommandInset citation
LatexCommand cite
key "Osrm"
literal "false"

\end_inset

, which describes itself as a 
\begin_inset Quotes eld
\end_inset

modern C++ routing engine for shortest paths in road networks
\begin_inset Quotes erd
\end_inset

, capable of handling 
\begin_inset Quotes eld
\end_inset

continental sized networks within milliseconds
\begin_inset Quotes erd
\end_inset

.
 In addition, a prior project of my own, osm-signal 
\begin_inset CommandInset citation
LatexCommand cite
key "OsmSignal"
literal "false"

\end_inset

, used this graph data structure and a shortest-path algorithm in order
 to find the shortest path between two railway stations on the UK rail network.
 However, there are numerous different shortest-path graph-search algorithms
 available for use, necessitating research into this field.
\end_layout

\begin_layout Subsubsection
Dijkstra's algorithm
\end_layout

\begin_layout Standard
Dijkstra's algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "dijkstra1959note"
literal "false"

\end_inset

 was devised in 1956 by Edger W.
 Dijkstra, and is employed in both OSRM (where it is not the default, but
 where there is the option of using a slightly modified method - 
\begin_inset Quotes eld
\end_inset

multi-level Dijkstra
\begin_inset Quotes erd
\end_inset

) and osm-signal.
 It roughly works as follows:
\end_layout

\begin_layout Enumerate
Assign each node a 
\emph on
distance
\emph default
 (from the starting node).
 The starting node has distance zero, and all other have distance 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
infty$
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
Create a set of unvisited nodes whose elements are initially every node
 in the graph.
 (In osm-signal, a binary heap was used instead, to optimize performance.).
 Set the 
\emph on
current node
\emph default
 to the starting node.
\end_layout

\begin_layout Enumerate
Consider all unvisited neighbours of the current node, calculating their
 distances through the current node (i.e.
 calculate their distance as the distance value of the current node, plus
 the distance between the two nodes).
 Compare this 
\emph on
tentative
\emph default
 distance to the current distance value of the neighbour, and assign the
 smallest one.
\end_layout

\begin_layout Enumerate
Mark the current node as visited, and remove it from the unvisited set.
\end_layout

\begin_layout Enumerate
If the destination node is marked with the smallest unvisited distance,
 stop.
\end_layout

\begin_layout Enumerate
Otherwise, select the unvisited node that is marked with the smallest distance,
 set it as the new current node, and go to step 3.
\end_layout

\begin_layout Standard
Dijkstra's algorithm is relatively simple to implement, but is thought of
 by the OSRM developers as only 
\begin_inset Quotes eld
\end_inset

moderately fast in both pre-processing and query
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "OsrmConfig"
literal "false"

\end_inset

.
 Indeed, my osm-signal implementation was qualitatively also rather slow,
 taking at least 5 seconds for some routing queries.
 However, it has the advantage of being relatively easy to show correctness
 of; there are relatively few mistakes to be made in its implementation,
 and the proof of Dijkstra's algorithm is considered trivial enough to be
 proved in one or two pages by various university departments, presumably
 as a part of their courses: Oregon State University present an easily understan
dable one-page proof by induction 
\begin_inset CommandInset citation
LatexCommand cite
key "OregonDjikstra"
literal "false"

\end_inset

, while UC Davis' Computer Science prove it similarly easily in two pages
 
\begin_inset CommandInset citation
LatexCommand cite
key "UcDavisDijkstra"
literal "false"

\end_inset

.
 This, along with its relative simplicity, would make it an ideal choice
 for the project, providing that it were not shown to be too slow.
\end_layout

\begin_layout Subsubsection
Contraction Hierarchies
\end_layout

\begin_layout Standard
The OSRM project prefers the use of an algorithmic approach called Contraction
 Hierarchies 
\begin_inset CommandInset citation
LatexCommand cite
key "geisberger2008contraction"
literal "false"

\end_inset

, proposed by Robert Geisberger in 2008.
 It presents 
\begin_inset Quotes eld
\end_inset

a route planning technique solely based on the concept of node contraction
\begin_inset Quotes erd
\end_inset

, which involves adding 
\begin_inset Quotes eld
\end_inset

shortcut edges
\begin_inset Quotes erd
\end_inset

 to the graph - essentially, they use a modified version of Dijkstra's algorithm
, but pre-process the graph to create shortcuts between groups of nodes,
 depending on how 
\begin_inset Quotes eld
\end_inset

important
\begin_inset Quotes erd
\end_inset

 various edges are deemed to be.
 It is evident how this is useful for OSRM, as routing across large nationwide
 road networks would surely benefit from prioritising the consideration
 of major highways and carriageways over small local roads.
 However, as noted in the OSRM source code, CH provides 
\begin_inset Quotes eld
\end_inset

extremely fast queries, but slow pre-processing
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "OsrmConfig"
literal "false"

\end_inset

 - a potential downside of such an algorithm.
 In addition, CH is a non-trivial algorithm to understand and implement
 - their query algorithm is 
\begin_inset Quotes eld
\end_inset

a symmetric Dijkstra-like bidirectional procedure
\begin_inset Quotes erd
\end_inset

 that requires an 
\begin_inset Quotes eld
\end_inset

interleaved...forward and backward search
\begin_inset Quotes erd
\end_inset

.
 Therefore, it is questionable as to whether the time required to understand
 it, implement it, and verify its correctness can be justified.
\end_layout

\begin_layout Subsubsection
A*
\end_layout

\begin_layout Standard
The A* search algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "hart1968formal"
literal "false"

\end_inset

, introduced in 1967, mentions a 
\begin_inset Quotes eld
\end_inset

heuristic approach
\begin_inset Quotes erd
\end_inset

 to the problem, involving 
\begin_inset Quotes eld
\end_inset

special knowledge about the domain of the problem being represented
\begin_inset Quotes erd
\end_inset

 - i.e.
 making use of the fact that the graph used to model points in space is
 not just an arbitrary graph, using a 
\emph on
heuristic function
\emph default
 (for example, the as-the-crow-flies distance between two locations) to
 direct the search toward areas more likely to lead to the goal node.
 A* can be seen as an extension of Dijkstra's algorithm - in step 6 from
 the description earlier, when choosing a node to consider next, A* adds
 the nodes' distance to the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout

$h(n)$
\end_layout

\end_inset

 - i.e.
 the heuristic function applied to the node, thus choosing nodes more likely
 to lead to the goal first.
 This avoids the problem of 
\begin_inset Quotes eld
\end_inset

using absolutely no information from the problem domain
\begin_inset Quotes erd
\end_inset

 evident with the plain version of Dijkstra's algorithm, allowing the algorithm
 to 
\begin_inset Quotes eld
\end_inset

still find the shortest path, but...do so by expanding, typically, considerably
 fewer nodes
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Since this algorithm is a relatively simplistic extension of Dijkstra's
 algorithm, it is similarly rather simple to implement, whilst bringing
 noticeable efficiency benefits - as clearly shown when viewing a visualisation
 of Dijkstra's algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "DijkstraVis"
literal "false"

\end_inset

 and comparing this to one of A* 
\begin_inset CommandInset citation
LatexCommand cite
key "AstarVis"
literal "false"

\end_inset

; A* quite quickly heads straight for the goal node, routing around an obstacle,
 while Dijkstra wastes time exploring in all directions away from the start
 node, when most of them would never yield the shortest path.
\end_layout

\begin_layout Subsubsection
Evaluation and comparison
\end_layout

\begin_layout Standard
Given the large number of possible graph search algorithms, each with their
 own application-specific properties, it seems unlikely that a general judgement
 of which algorithm is superior can be reached.
 However, at this initial research stage, A* looks to be the best way forward
 for this project, given its minimal complexity - it's just a slightly modified
 version of Dijkstra's algorithm - and supposedly acceptable performance.
 At a later stage, of course, it may well be required to investigate implementin
g Contraction Hierarchies or another, more advanced graph search algorithm,
 if performance proves to be an issue.
\end_layout

\begin_layout Section
Design
\end_layout

\begin_layout Subsection
System structure
\end_layout

\begin_layout Standard
The first stage of the design process involves defining and justifying what
 exactly must be created - i.e.
 how should the project structure itself, and what discrete software components
 should be created to provide the required system? Since there were a number
 of ways in which the project could be structured, I decided to perform
 a brief analysis of which structure the project should use.
 
\begin_inset CommandInset label
LatexCommand label
name "subsec:System-structure"

\end_inset


\end_layout

\begin_layout Subsubsection
Required functionality
\end_layout

\begin_layout Standard
From the PPF, the required functionality of the whole project amounts to:
\end_layout

\begin_layout Itemize
determining the current location of the user;
\end_layout

\begin_layout Itemize
providing A-to-B turn-by-turn navigation to the user (which involves calculating
 the shortest route between two points, and splitting this into discrete
 turn-by-turn instructions);
\end_layout

\begin_layout Itemize
estimating the user's time of arrival;
\end_layout

\begin_layout Itemize
providing a mobile interface to the system, usable on both iOS and Android.
\end_layout

\begin_layout Standard
In addition, the proposed architecture should ideally maintain 
\emph on
genericity
\emph default
 - while this EPQ will implement the system for one specific deployment,
 it would be ideal if the system could easily be extended to others without
 changing the code or architecture significantly.
\end_layout

\begin_layout Standard
However, there are a number of ways in which this functionality could potentiall
y be implemented.
\end_layout

\begin_layout Subsubsection
Proposal 1: monolithic mobile application
\end_layout

\begin_layout Standard
Arguably the simplest possible architecture for the system would involve
 just one mobile application, which would perform all necessary tasks required
 for navigation, relying in no way on any server-side component.
\end_layout

\begin_layout Standard
This would be rather unconventional for navigation applications - most common
 apps on the market (e.g.
 Google Maps, Waze) introduce an extra server-side component for their routing.
 However, it is possible - for example, the Android application OSMAnd~
 does all of its routing offline, using downloaded OpenStreetMap data.
\end_layout

\begin_layout Paragraph
Advantages
\end_layout

\begin_layout Itemize
No need to maintain multiple codebases, or familiarise oneself with multiple
 development frameworks; only one software application is created (potentially
 reducing development time)
\end_layout

\begin_layout Itemize
No internet connection required, once the application is installed (all
 data is local) - making the app ideal for areas without internet
\end_layout

\begin_layout Itemize
No need to consider interaction between multiple different parts of the
 system; everything takes place in one mobile app
\end_layout

\begin_layout Itemize
Performance not dependent on network lag, as no internet connection is used
\end_layout

\begin_layout Paragraph
Disadvantages
\end_layout

\begin_layout Itemize
Performance dependent on the user's phone - if their phone is slow, application
 performance may suffer or cause lag when performing more compute-intensive
 tasks, like graph searching
\end_layout

\begin_layout Itemize
Battery life may suffer, if the application performs many compute-intensive
 tasks
\end_layout

\begin_layout Itemize
Size of application is greater, due to required offline data & increased
 code size
\end_layout

\begin_layout Itemize
An update of the whole application is required to make any changes - potentially
 slowing down development or rollout of new features
\end_layout

\begin_layout Itemize
Such an architecture creates a greater dependency on the mobile application
 framework used; switching to a native approach, or rewriting the app to
 use another framework, would mean rewriting all of the system's code
\end_layout

\begin_layout Itemize
Specific applications must be created for each possible deployment of the
 system, reducing genericity - since the app needs all data for a given
 deployment, it becomes harder to adapt it for new buildings without creating
 a separate version of the app for that new deployment (or by bundling lots
 of different datasets into one generic app, further increasing size)
\end_layout

\begin_layout Subsubsection
Proposal 2: client-server architecture
\end_layout

\begin_layout Standard
An alternative architecture, and indeed that employed by commonly-used tradition
al navigation applications like Google Maps, is to split the system into
 a mobile 
\begin_inset Quotes eld
\end_inset

client
\begin_inset Quotes erd
\end_inset

 component and a 
\begin_inset Quotes eld
\end_inset

server
\begin_inset Quotes erd
\end_inset

 component, where the client is used to obtain input from the user and display
 navigation guidance, while the server performs more compute-intensive tasks,
 like finding a route between two points.
 This also involves specifying how the two components will interact - i.e.
 defining the application programming interface (API) for the server.
\end_layout

\begin_layout Paragraph
Advantages
\end_layout

\begin_layout Itemize
Compute-intensive tasks can be offloaded to a more powerful server component,
 improving app responsiveness and battery life
\end_layout

\begin_layout Itemize
New routing information, or improvements to the routing algorithm, can be
 incorporated into the server without a change in client code
\end_layout

\begin_layout Itemize
The size of the mobile application is reduced, as it mustn't download all
 data required for routing
\end_layout

\begin_layout Itemize
Any server-side programming language can be used, as long as it implements
 the specified API; furthermore, it becomes easier to change the mobile
 framework used, as less code must be rewritten
\end_layout

\begin_layout Itemize
The same client application could be used for multiple deployments, given
 a generic API - different deployments would just use a different server-side
 component
\end_layout

\begin_layout Paragraph
Disadvantages
\end_layout

\begin_layout Itemize
Two separate components must be developed, in addition to an API specification,
 potentially increasing development time
\end_layout

\begin_layout Itemize
A network connection is required for the app to be useful
\end_layout

\begin_layout Subsubsection
Proposal 3: client with lightweight server
\end_layout

\begin_layout Standard
As a compromise between the two, another alternative architecture could
 involve one mobile application, similar to Proposal 1, that incorporated
 all necessary functionality but left out any required datasets (e.g.
 map tiles and other routing information), along with a 'dumb' server, from
 which the mobile application could download its data if and when required
 (e.g.
 at startup, and when the data changes).
 This would involve the same development workload as Proposal 1 (the server-side
 component could simply reuse an off-the-shelf HTTP server, like nginx,
 to host the data files on), while keeping some flexibility (the data could
 be changed and pushed to the mobile clients without them completely reinstallin
g the application).
\end_layout

\begin_layout Paragraph
Advantages
\end_layout

\begin_layout Itemize
The app's data can be updated without reinstalling the application
\end_layout

\begin_layout Itemize
The app is still generic, as different servers could provide different datasets
 for different employments
\end_layout

\begin_layout Itemize
Once the app had downloaded its data, it could work offline from then on
 until an update was desired
\end_layout

\begin_layout Itemize
No need to maintain multiple codebases, or design an API (as before)
\end_layout

\begin_layout Paragraph
Disadvantages
\end_layout

\begin_layout Itemize
This solution doesn't address the performance concerns from Proposal 1;
 only the ones about genericity and data freshness.
\end_layout

\begin_layout Itemize
Changes to the routing algorithm are still impossible without an app update
 - only data can be changed
\end_layout

\begin_layout Subsubsection
Evaluation
\end_layout

\begin_layout Standard
In terms of developer ergonomics and time constraints, Proposals 1 and 3
 look to be optimal, making them potential candidates for the project's
 architecture.
 However, the performance disadvantage mentioned in Proposal 2 is not to
 be overlooked; from prior experience, a reasonably naïve implementation
 of Djikstra's algorithm in osm-signal managed to saturate all four cores
 of a reasonably powerful server machine, taking a not insignificant amount
 of time to complete its routing task.
 Of course, the performance requirements might be smaller on an indoor scale,
 especially depending on where the system is deployed, but the time required
 to tune code to be optimized for performance and battery life might well
 cancel out any benefits saved by simplifying the overall architecture.
\end_layout

\begin_layout Standard
Furthermore, a client-server architecture opens the door to further innovation
 and extension of the project, especially with regards to the creation of
 new clients - for example, a web interface for users at a desktop computer
 could be created, reusing most of the server-side code.
\end_layout

\begin_layout Standard
Therefore, I decided to go with Proposal 2 for the overall architecture
 of the system, despite the potential complexity increase from writing multiple
 pieces of code, as I believed it would provide the most optimal user experience
, and provide flexibility for further extension once created.
\end_layout

\begin_layout Subsection
React Native setup
\end_layout

\begin_layout Standard
In the research section, React Native was identified as the mobile framework
 to use for this project.
 However, many design decisions still need to be made when implementing
 the application - the first of which was immediately presented in the 
\begin_inset Quotes eld
\end_inset

Getting Started
\begin_inset Quotes erd
\end_inset

 section of the React Native documentation.
 React Native's initial tutorial offers a choice between Expo, 
\begin_inset Quotes eld
\end_inset

the easiest way to start building a new React Native application
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "RnGettingStarted"
literal "false"

\end_inset

, and 
\begin_inset Quotes eld
\end_inset

building projects with native code
\begin_inset Quotes erd
\end_inset

.
 However, it was unclear as to which option should be taken - both options
 had their advantages and disadvantages, necessitating a more thorough analysis.
\end_layout

\begin_layout Subsubsection
Expo
\end_layout

\begin_layout Standard
Expo is, according to their website, 
\begin_inset Quotes eld
\end_inset

a free and open source toolchain built around React Native
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "ExpoIo"
literal "false"

\end_inset

 - essentially, it provides a framework for developers to get started with
 writing React Native apps without having to compile any native code.
 The tutorial states as such - running the application simply entails 
\begin_inset Quotes eld
\end_inset

install[ing] the Expo client app on your...phone and connect[ing] to the same
 wireless network as your computer
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "RnGettingStarted"
literal "false"

\end_inset

, and then scanning a QR code.
 In addition, using Expo Snack 
\begin_inset CommandInset citation
LatexCommand cite
key "ExpoSnack"
literal "false"

\end_inset

, it's possible to run Expo apps in the browser, without using a phone at
 all.
\end_layout

\begin_layout Standard
Expo also provide the Expo SDK 
\begin_inset CommandInset citation
LatexCommand cite
key "ExpoSdk"
literal "false"

\end_inset

, an easy-to-use library that bundles a set of native functionality, avoiding
 the need to use other third-party libraries - including, for example, an
 accelerometer library, as required by this project.
\end_layout

\begin_layout Paragraph
Advantages
\end_layout

\begin_layout Itemize
Easier to develop applications, as Expo handles interacting with the React
 Native toolchain for you
\end_layout

\begin_layout Itemize
Expo comes bundled with an easy-to-use SDK & library set
\end_layout

\begin_layout Itemize
Published applications can be updated over-the-air, without pushing new
 versions of the app to app stores
\end_layout

\begin_layout Itemize
Using Expo doesn't limit a developer's ability to publish to app stores
\end_layout

\begin_layout Itemize
There's no need to handle downloading & installing Android Studio or Xcode,
 reducing disk space usage on the developer's machine
\end_layout

\begin_layout Paragraph
Disadvantages
\end_layout

\begin_layout Itemize
Reliant on the Expo infrastructure: an Expo app still needs to download
 its assets (code, etc.) from Expo's servers on first boot, and thus cannot
 do 
\emph on
anything
\emph default
 until given an internet connection
\end_layout

\begin_deeper
\begin_layout Itemize
This can be solved by buiding a standalone app - but the docs note that
 connectivity is still required for updates.
\end_layout

\end_deeper
\begin_layout Itemize
Expo 
\begin_inset Quotes eld
\end_inset

includes a bunch of APIs regardless of whether or not you are using them
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "WhyNotExpo"
literal "false"

\end_inset

, increasing binary size
\end_layout

\begin_layout Itemize
Expo apps 
\begin_inset Quotes eld
\end_inset

don't support background code execution
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "WhyNotExpo"
literal "false"

\end_inset

 - for example, a navigation app couldn't provide guidance unless it was
 permanently in the foreground
\end_layout

\begin_layout Itemize
If the Expo SDK doesn't cover your use-case, using third-party libraries
 is harder, and in some cases, impossible:
\end_layout

\begin_deeper
\begin_layout Itemize
most third-party libraries assume you aren't using Expo (for example, 
\family typewriter
react-native-sensors
\family default
 and 
\family typewriter
react-native-svg-charts
\family default
, both used later on), causing difficulty when trying to use these
\end_layout

\begin_layout Itemize
third-party libraries using native code 
\emph on
cannot
\emph default
 be used with Expo (without 'ejecting' and transforming the app into a regular
 React Native app)
\end_layout

\end_deeper
\begin_layout Subsubsection
Evaluation
\end_layout

\begin_layout Standard
Expo seemed like a useful way to get started with React Native, albeit one
 that prioritised ergonomics in the short-term over long-term sustainable
 development.
 While Expo may be very useful for simple apps, where functionality is completel
y covered by the Expo SDK, going with Expo carries the risk of having to
 
\begin_inset Quotes eld
\end_inset

eject
\begin_inset Quotes erd
\end_inset

 later, somewhat reducing the advantages of going with Expo in the first
 place (as then a native toolchain would be required to continue working
 on the project, precisely as Expo aims to avoid).
\end_layout

\begin_layout Standard
In addition, the 
\begin_inset Quotes eld
\end_inset

kitchen sink
\begin_inset Quotes erd
\end_inset

 nature of Expo made it less of a good fit for this project (bundling unnecessar
y libraries that increased app size was unwanted) - as well as the fact
 that libraries not covered by the Expo SDK would potentially be harder
 to use - meant that its use for this project seemed increasingly less necessary.
 Therefore, I decided to attempt setting up React Native without Expo; if
 it proved to be too challenging, Expo could always be used to ease the
 experience at a later date (whereas starting with Expo and 'ejecting' could
 potentially be painful).
\end_layout

\begin_layout Subsubsection
Toolchain setup
\end_layout

\begin_layout Standard
In order to facilitate easy development of the app throughout the project
 duration, the React Native setup instructions were followed - albeit in
 an Arch Linux 
\family typewriter
chroot
\family default
 on a portable hard-disk drive (HDD).
 This setup enabled me to both reduce disk space usage on my main machines
 (as Android Studio could be installed on the portable HDD), as well as
 enabling me to develop the app on both my laptop and my desktop machines.
\end_layout

\begin_layout Standard
To perform testing, I opted to use my personal Android phone, configured
 to allow USB debugging; whilst an Android emulator would have been an option,
 it would have been useless for testing step detection (due to the lack
 of emulated accelerometer), whilst also potentially being resource-intensive
 on my development machines.
\end_layout

\begin_layout Standard
Following the tutorial to set this up, then, I was able to compile, build
 and run the example 
\begin_inset Quotes eld
\end_inset

Hello World
\begin_inset Quotes erd
\end_inset

 application on my phone, allowing development to continue (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-React-Native"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/eeeeeta/engineering-epq/screenshots/welcome_to_rn.png
	width 20page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The React Native 
\begin_inset Quotes eld
\end_inset

hello world
\begin_inset Quotes erd
\end_inset

 application (screenshot from mobile).
\begin_inset CommandInset label
LatexCommand label
name "fig:The-React-Native"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\family typewriter
react-native-sensors
\family default
 setup and testing
\end_layout

\begin_layout Standard
The next step was to write a small React Native application, in order to
 verify that the accelerometer worked and could generate usable readings.
 To accomplish this, the 
\family typewriter
react-native-sensors
\family default
 library was chosen (as justified earlier), as well as the 
\family typewriter
react-native-svg-charts
\family default
 library 
\begin_inset CommandInset citation
LatexCommand cite
key "RnSvgCharts"
literal "false"

\end_inset

 for graph plotting (which featured prominently on Google; since this was
 just a test, an in-depth evaluation was not performed).
 This application was able to demonstrate that moving the phone up and down
 manually, or, indeed, walking with it, generated noticeable changes in
 the accelerometer Z readings (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:accel-testing"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 This was promising when read in conjunction with the FootPath paper, which
 stated that 
\begin_inset Quotes eld
\end_inset

we can detect a step by matching the values to a sharp drop in acceleration,
 attributed to the jiggling of the phone
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "link2011footpath"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/eeeeeta/engineering-epq/screenshots/accel_testing_graph.png
	width 20page%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Screenshot of the accelerometer testing app created for evaluation purposes.
 The three sliders show changes in the x, y, and z values respectively,
 while the graph plots the change in the z value.
\begin_inset CommandInset label
LatexCommand label
name "fig:accel-testing"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Low-pass filter implementation and evaluation
\end_layout

\begin_layout Standard
However, the FootPath paper mentioned the necessity for 
\begin_inset Quotes eld
\end_inset

a low pass filter
\begin_inset Quotes erd
\end_inset

 in order 
\begin_inset Quotes eld
\end_inset

to further improve detection
\begin_inset Quotes erd
\end_inset

, so a new version of the application was developed to incorporate this
 change.
 For quick testing purposes, the top-ranked result on Google was chosen,
 leading to the 
\family typewriter
lpf
\family default
 library by GitHub user 
\family typewriter
uhho
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "LpfLibrary"
literal "false"

\end_inset

.
 This library, however, did seem somewhat unmaintained, with its latest
 commit being in April 2014; nevertheless, a testing implementation was
 still made (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:accel-testing-lpf"
plural "false"
caps "false"
noprefix "false"

\end_inset

), in order to verify whether it worked despite being unmaintained (indeed,
 that may be no problem for a simple library like this).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/eeeeeta/engineering-epq/screenshots/accel_testing_graph_lpf.png
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Screenshot of a modified accelerometer testing app (with sliders as in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:accel-testing"
plural "false"
caps "false"
noprefix "false"

\end_inset

), now incorporating a 'LPF smoothing' slider, used to adjust the parameters
 for the low-pass filter.
\begin_inset CommandInset label
LatexCommand label
name "fig:accel-testing-lpf"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
It was, however, hard to tell whether the LPF had any effect on the results
 or not; since the library chosen for graph plotting, 
\family typewriter
react-native-svg-charts
\family default
, did not provide any indication as to the axis scaling, the plotted graph
 with the LPF enabled looked almost the same as the one without it - which
 could either be due to a failure in the LPF, or simply because the graphing
 library changed its scaling with the new data, zooming in on what is actually
 a smaller amount of noise.
 However, attempting to coerce the graphing library into scaling consistently
 seemed like a poor use of time - moving on to implementing the step sensing
 component would show whether or not the LPF worked quickly enough; if it
 didn't work, work on the graphing library could be done later.
\end_layout

\begin_layout Subsection
Step sensing & path matching
\end_layout

\begin_layout Standard
As previously discussed, a preliminary implementation of FootPath was completed
 during the research stage of the project, in the Rust programming language.
 In order to test this, the code was ported rather naïvely to JavaScript
 for use with React Native (no attempts were made at this juncture to optimize
 the code in any way, although the preliminary implementation used was not
 very optimized; such work could always be done later if performance proved
 to be a real problem).
 In addition, the FootPath step detection algorithm was also implemented,
 using the data from the 
\family typewriter
react-native-sensors
\family default
 API and LPF system described earlier.
\end_layout

\begin_layout Subsubsection
Step detection algorithm
\end_layout

\begin_layout Standard
The step detection algorithm component of FootPath has a number of tweakable
 parameters 
\begin_inset CommandInset citation
LatexCommand cite
key "link2011footpath"
literal "false"

\end_inset

 - the difference in acceleration (
\family typewriter
difference_accel
\family default
) required to detect a step; the time window during which a step can be
 detected (
\family typewriter
window_ms
\family default
); and the timeout after step detection, after which no more steps can be
 detected (
\family typewriter
timeout_ms
\family default
).
 These were exposed via sliders in a testing application (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:step-detection-screenshot"
plural "false"
caps "false"
noprefix "false"

\end_inset

) that logged the user's steps (logging the acceleration required to trigger
 the step, as well as the UNIX timestamp of the step), allowing the step
 detection to be preliminarily evaluated.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/eeeeeta/engineering-epq/screenshots/step_detector_testing_2.png
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Screenshot of a step detection testing app, with sliders exposing the relevant
 adjustable parameters for the step-detection algorithm, as well as the
 LPF smoothing parameter from earlier app revisions.
 A list shows the acceleration associated with each detected step, as well
 as the step's UNIX timestamp; a button is also provided to clear the list
 of steps.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:step-detection-screenshot"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Step detection evaluation
\end_layout

\begin_layout Standard
The values specified by the FootPath authors were found to work reasonably
 well, but often counted steps twice or counted false steps; it was hypothesized
 that these differences may well be, as the paper says, due to the need
 to calibrate the parameters, especially for different phones - although
 the FootPath authors stated that 
\begin_inset Quotes eld
\end_inset

they repeated [a step-detection testing] experiment with 15 users and found
 the parameters to be robust against body heights and walking styles
\begin_inset Quotes erd
\end_inset

 (where this 'experiment' is not very detailed, drawing suspicions as to
 the true reliability of this statement), they also note that 
\begin_inset Quotes eld
\end_inset

the parameters...can be calibrated to further improve step detection performance
 on a per-user basis
\begin_inset Quotes erd
\end_inset

.
 This variability was highlighted as something that needed to be accounted
 for in the design process later on; while it was possible to adjust the
 parameters to work reliably on one phone, the accelerometer behaviours
 for different phones and users may differ, such that incorporating a calibratio
n step in the app's setup flow might be required to ensure smooth operation.
 The manner in which the phone was held was also a factor - in preliminary
 tests, allowing the phone to shake too much while walking logged more steps
 with the default parameters (requiring a change for accurate readings),
 whilst attempting to hold the phone relatively still demonstrated good
 performance with the default parameters - strengthening the need for some
 sort of calibration step (this jiggling behaviour could be protected against
 by increasing 
\family typewriter
timeout_ms
\family default
 - indeed, doing so in tests appeared to fix the erroneous readings).
\end_layout

\begin_layout Standard
It was also hoped that the path matching algorithm would provide a layer
 of protection against erroneous readings as well - although dependent on
 the exact path chosen: a straight line path would demonstrate zero protection
 against repeated readings in the correct direction, while a path incorporating
 frequent turns should refuse to indicate as much progress due to repeated
 steps.
 To verify this assumption, and also to proceed further with the project,
 an implementation of the path matching algorithm was carried out.
\end_layout

\begin_layout Subsubsection
Path matching algorithm
\end_layout

\begin_layout Standard
To test the path matching algorithm, the step detection testing app was
 updated to use the JavaScript implementation of the FootPath Best Fit algorithm
 – however, it could not match steps to a predetermined path yet, as the
 routing server and navigation graph search system had not yet been completed.
 To remedy this omission for testing purposes, a system was designed to
 enable the user to first record a series of steps, then flick a switch
 and run the Best Fit algorithm against these recorded steps and the user's
 new steps, giving a position readout.
 In addition, heading data was added to the detected and recorded steps
 to make the FootPath implementation work (as this is the data it uses to
 match up the steps).
 This system, then, was implemented in a new version of the app (Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:footpath-screenshot"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and some preliminary testing was conducted.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/eeeeeta/engineering-epq/screenshots/footpath_testing.png
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Screenshot of a FootPath testing app.
 Here, the same controls are exposed as in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:step-detection-screenshot"
plural "false"
caps "false"
noprefix "false"

\end_inset

, in addition to controls that enable the user to enable step detection
 and step recording, as well as clear the recorded and detected step lists.
 As before, a list of steps is shown, albeit now with headings; these steps
 also feed into the 
\begin_inset Quotes eld
\end_inset

Pos
\begin_inset Quotes erd
\end_inset

 readout, which shows progress along the recorded path according to the
 FootPath algorithm.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:footpath-screenshot"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Path matching evaluation
\end_layout

\begin_layout Standard
In simple tests with one tester on one phone walking around a building,
 the Best Fit algorithm seemed to work rather well in the 
\begin_inset Quotes eld
\end_inset

happy path
\begin_inset Quotes erd
\end_inset

 case where the tester follows the recorded route pretty much exactly, accuratel
y reporting their position along the route as they did so.
 Performance when the tester intentionally deviated from the recorded route
 was varied - while the algorithm would resume displaying progress accurately
 if the user returned to the recorded route, the initial deviations could
 cause the measured position to progress erratically or jump around (for
 example, if the recorded route was a rectangle, starting by walking backwards
 instead of forwards caused the app to assume the tester had skipped the
 first two edges of the rectangle and was walking back toward the start,
 causing a jump).
 Repeated steps away from the route, however, would eventually stall the
 progress indicator, requiring the tester to return to the route in order
 to obtain any indications of further progress.
\end_layout

\begin_layout Standard
Therefore, it was determined that the design of the final application would
 likely need to incorporate some mechanisms to deal with this erratic behaviour
 in the case of user error - for example, triggering a warning dialog if
 the estimated position jumped too significantly (perhaps asking the user
 to re-input their position).
 It might also have been the case that the implementation of Best Fit was
 in some way incorrect.
 However, the FootPath paper unfortunately provided no test cases to check
 a new implementation against, making checking for subtle implementation
 differences rather difficult; the overall behaviour of the algorithm seemed
 to mirror the descriptions given in the paper 
\begin_inset CommandInset citation
LatexCommand cite
key "link2011footpath"
literal "false"

\end_inset

 (
\begin_inset Quotes eld
\end_inset

Best Fit matches each direction onto the path to where it received the smallest
 penalty...if the directions match better to a previous position on the path,
 it will fall back and continue from there
\begin_inset Quotes erd
\end_inset

).
 In addition, there is the issue of compass inaccuracy to contend with;
 since the steps were recorded on a smartphone with a potentially inaccurate
 compass, the algorithm may have performed worse than expected.
\end_layout

\begin_layout Standard
Since none of these issues seemed to indicate that the step detection /
 path matching subsystems were fatally flawed (indeed, they raised a number
 of important design considerations), progress was made on other parts of
 the project.
\end_layout

\begin_layout Subsection
Routing server & API
\end_layout

\begin_layout Standard
As discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:System-structure"
plural "false"
caps "false"
noprefix "false"

\end_inset

, the project requires two components to be developed: a client-side mobile
 application, to run on the user's phone, and the routing server, which
 will expose a defined Application Programming Interface (API) to the client-sid
e application, through which paths from A to B can be calculated and returned
 to the client-side app for display to the user.
 However, there are still a number of design considerations to discuss with
 regards to exactly how the routing server will be implemented.
\end_layout

\begin_layout Subsubsection
Programming languages
\end_layout

\begin_layout Standard
The question of which programming language to use for a project is not a
 simple one.
 With React Native, the choice was made for us (as JavaScript must be used);
 however, any language could conceivably be used to implement the routing
 server.
 An exhaustive list of all popular programming languages and in-depth analysis
 would be somewhat out of scope for this writeup; furthermore, given the
 limited time available for this project, it makes sense to use an already
 familiar language, as the main goal of the project is not to aim to explore
 new programming languages, but rather to focus on implementing what has
 been (and will be) designed.
\end_layout

\begin_layout Standard
That said, there are also a number of design constraints a programming language
 would ideally fulfil, in order to meet the needs of this project - namely:
\end_layout

\begin_layout Itemize
Fast performance - the program has to be able to run Djikstra's algorithm
 (or another graph-search algorithm) as fast as possible, with minimal language
 overhead, to meet the user's performance expectations
\end_layout

\begin_layout Itemize
Developer ergonomics - it should be possible to start writing the program
 with minimal fussing around with the language, as doing so wastes valuable
 time
\end_layout

\begin_layout Itemize
Good support for handling web requests - due to the need for the program
 to serve an HTTP API to the client component
\end_layout

\begin_layout Itemize
Reliability - in order to provide a reliable service to the end-user, the
 language should provide good support for error handling & management, to
 avoid unexpected failures
\end_layout

\begin_layout Paragraph
Rust
\end_layout

\begin_layout Standard
The Rust programming language 
\begin_inset CommandInset citation
LatexCommand cite
key "TrplWebsite"
literal "false"

\end_inset

 is a relatively new systems programming language, developed by Graydon
 Hoare and Mozilla Research.
 It performs rather well according to these criteria:
\end_layout

\begin_layout Itemize
Performance - according to the website, Rust is 
\begin_inset Quotes eld
\end_inset

blazingly fast and memory-efficient, with no runtime or garbage collector
\begin_inset Quotes erd
\end_inset

 to slow it down.
 Whilst performance measurements are always rather difficult to pin down,
 and often vary according to use-case, Rust does score highly in benchmarks
 such as the Computer Language Benchmarks Game 
\begin_inset CommandInset citation
LatexCommand cite
key "ClbgRust"
literal "false"

\end_inset

 (with the fastest submitted program for 5 out of the 10 benchmarks being
 written in Rust, at the time of writing) and the TechEmpower Web Framework
 benchmarks 
\begin_inset CommandInset citation
LatexCommand cite
key "TechEmpowerRustJson"
literal "false"

\end_inset

 (occupying 6th place in the 'JSON serialization test' for the 2018-10-30
 Round 17 series, for example).
\end_layout

\begin_layout Itemize
Developer ergonomics - again, the website boasts of 
\begin_inset Quotes eld
\end_inset

great documentation, a friendly compiler with useful error messages, and
 top-notch tooling
\begin_inset Quotes erd
\end_inset

.
 Given past experience developing projects like osm-signal 
\begin_inset CommandInset citation
LatexCommand cite
key "OsmSignal"
literal "false"

\end_inset

, this is no lie; both the expressiveness of the actual language (including
 trait-based generics, built-in macro support, and other helpful language
 features) and the excellent tooling, like the Cargo package manager, make
 for a pleasant developer experience.
\end_layout

\begin_layout Itemize
Web requests - according to 
\begin_inset Quotes eld
\end_inset

Are we web yet?
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "RustAwwy"
literal "false"

\end_inset

, a website created to summarize track Rust's progress in the field of web
 development, Rust is evaluated as being at the 
\begin_inset Quotes eld
\end_inset

you can build stuff!
\begin_inset Quotes erd
\end_inset

 stage - whilst noting that 
\begin_inset Quotes eld
\end_inset

various frameworks enable you to build APIs and backend services quickly
\begin_inset Quotes erd
\end_inset

, the website ultimately claims that 
\begin_inset Quotes eld
\end_inset

a lot more web-specific needs are still unmet and immature
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Reliability - Rust's website boasts that 
\begin_inset Quotes eld
\end_inset

Rust’s rich type system and ownership model guarantee memory-safety and
 thread-safety
\begin_inset Quotes erd
\end_inset

, whilst Rust's strong type system also helps prevent bugs at compile-time.
 A recent 2017 paper on the topic more formally states that 
\begin_inset Quotes eld
\end_inset

Rust's linear type system enables capabilities that cannot be implemented
 efficiently in traditional languages, but safe and unsafe, and that dramaticall
y improve security and reliability of system software
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "balasubramanian2017system"
literal "false"

\end_inset

, while the abstract of a 2015 thesis investigating Rust's unique 
\emph on
ownership
\emph default
 type system summarizes that 
\begin_inset Quotes eld
\end_inset

Rust code is memory-safe by default, faster than C++, easier to maintain,
 and excels at concurrency
\begin_inset Quotes erd
\end_inset

 (claims which are somewhat unsubstantiated, but that do show support for
 the idea of Rust being memory-safe and therefore reliable).
\end_layout

\begin_layout Standard
In addition, Rust benefits from being a rather familiar language, given
 its ongoing use in other personal projects.
 This, combined with its near-excellent performance with respect to the
 identified necessary design constraints, makes it an ideal choice for the
 server-side component of the project.
\end_layout

\begin_layout Subsubsection
Web frameworks
\end_layout

\begin_layout Standard
Although Rust has already been specified as the programming language to
 use, there are a number of different web framework libraries to choose
 from.
\end_layout

\begin_layout Paragraph
Is a web framework necessary?
\end_layout

\begin_layout Standard
Support for handling web requests is not built into Rust; Rust's standard
 library only exposes the 
\family typewriter
std::net
\family default
 module, providing 
\begin_inset Quotes eld
\end_inset

networking functionality for the Transmission Control and User Datagram
 Protocols, as well as types for IP and socket addresses
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "RustStdNet"
literal "false"

\end_inset

 - providing the basic 
\begin_inset Quotes eld
\end_inset

building blocks
\begin_inset Quotes erd
\end_inset

 for higher-level protocols like HTTP, but not incorporating any HTTP request
 handling into the language.
\end_layout

\begin_layout Standard
Writing an HTTP library would be both a rather time-consuming task, and
 would also be somewhat out of scope for this project; it makes more sense
 to use somebody else's library.
 However, the libraries available differ - for example, in expansiveness
 (i.e.
 how much the library does for you, and how much you have to do yourself),
 in ergonomics (i.e.
 how easy it is to get up and running), and in what versions of Rust are
 supported by the library.
 Therefore, a comparison of which library would be best is in order.
\end_layout

\begin_layout Paragraph

\family typewriter
hyper
\end_layout

\begin_layout Standard
The 
\family typewriter
hyper
\family default
 library is 
\begin_inset Quotes eld
\end_inset

a fast HTTP implementation written in and for Rust
\begin_inset Quotes erd
\end_inset

, according to its website - providing 
\begin_inset Quotes eld
\end_inset

high concurrency with non-blocking sockets
\begin_inset Quotes erd
\end_inset

.
 It is one of the most popular HTTP libraries on 
\family typewriter
crates.io
\family default
, the Rust package repository, with 3.5 million all-time downloads 
\begin_inset CommandInset citation
LatexCommand cite
key "HyperCargo"
literal "false"

\end_inset

.
 However, it does use 'futures', a relatively new Rust paradigm for asynchronous
 computation, making it slightly more complex to make use of.
\end_layout

\begin_layout Standard
Furthermore, 
\family typewriter
hyper
\family default
 is primarily a library focused on the basic primitives that make up the
 HTTP protocol - it does not implement any 'web framework'-related functionality
, such as request routing (i.e.
 matching different URLs to different functions, such that, e.g.
 
\family typewriter
GET /homepage
\family default
 calls 
\family typewriter
homepage()
\family default
).
\end_layout

\begin_layout Subparagraph
Advantages
\end_layout

\begin_layout Itemize
Well-established library, under active development, with plenty of dependent
 crates and downloads
\end_layout

\begin_layout Itemize
Provides a strongly-typed API for many HTTP primitives (e.g.
 headers, error codes)
\end_layout

\begin_layout Itemize
Very performant, due to its use of asynchronous primitives and minimal nature
\end_layout

\begin_layout Itemize
Relatively minimal; doesn't try and implement much
\end_layout

\begin_layout Subparagraph
Disadvantages
\end_layout

\begin_layout Itemize
Uses Rust 
\family typewriter
Future
\family default
s: these are hard to use properly, and, from prior projects, often result
 in a lot of added complexity / boilerplate.
 Although Rust 
\family typewriter
async/await
\family default
 syntax is on the horizon to solve this issue, it is not possible as of
 the time of writing.
\end_layout

\begin_layout Itemize
Relatively minimal, which is a downside for our use-case: we ideally want
 the web framework to handle as much as possible, in order to concentrate
 our efforts on application logic
\end_layout

\begin_deeper
\begin_layout Itemize
Spending time writing our own request router - or even finding/gluing together
 other libraries in order to use someone else's - doesn't seem like a very
 good use of time.
\end_layout

\end_deeper
\begin_layout Paragraph

\family typewriter
rouille
\end_layout

\begin_layout Standard
The 
\family typewriter
rouille
\family default
 library 
\begin_inset CommandInset citation
LatexCommand cite
key "RouilleCargo"
literal "false"

\end_inset

 describes itself as 
\begin_inset Quotes eld
\end_inset

a micro-web-framework library
\begin_inset Quotes erd
\end_inset

, that was 
\begin_inset Quotes eld
\end_inset

designed to be intuitive to use if you know Rust
\begin_inset Quotes erd
\end_inset

.
 Its documentation 
\begin_inset CommandInset citation
LatexCommand cite
key "RouilleDocs"
literal "false"

\end_inset

 further claims that 
\begin_inset Quotes eld
\end_inset

the rouille library is very easy to get started with
\begin_inset Quotes erd
\end_inset

, providing a straightforward 5-line 
\begin_inset Quotes eld
\end_inset

hello world
\begin_inset Quotes erd
\end_inset

 example.
\end_layout

\begin_layout Standard
Essentially, 
\family typewriter
rouille
\family default
 is a step between bare-bones HTTP libraries like 
\family typewriter
hyper
\family default
 and fully-fledged web 
\emph on
frameworks
\emph default
 like 
\family typewriter
rocket
\family default
; providing a basic set of higher-level tools that can be used to construct
 a web application, without dictating too much about how the application
 is actually built.
 Indeed, reading 
\family typewriter
rouille
\family default
's README, it is stated that 
\begin_inset Quotes eld
\end_inset

concepts closely related to websites (like cookies, CGI, form input, etc.)
 are directly supported by rouille
\begin_inset Quotes erd
\end_inset

, while 
\begin_inset Quotes eld
\end_inset

more general concepts (like database handling or templating) are not directly
 handled
\begin_inset Quotes erd
\end_inset

 - essentially, describing what a so-called 
\begin_inset Quotes eld
\end_inset

micro-web-framework
\begin_inset Quotes erd
\end_inset

 library entails.
\end_layout

\begin_layout Subparagraph
Advantages
\end_layout

\begin_layout Itemize
Optimized for ease of use - unlike 
\family typewriter
hyper
\family default
, 
\family typewriter
rouille
\family default
's programming model entails 
\begin_inset Quotes eld
\end_inset

write a (synchronous) function that processes HTTP requests
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Built in functionality, like the 
\family typewriter
router!
\family default
 macro, to provide common functions like request routing, static file serving,
 HTML form parsing, etc.
 that might be required by a web server application, making development
 easier
\end_layout

\begin_layout Subparagraph
Disadvantages
\end_layout

\begin_layout Itemize

\emph on
Slightly
\emph default
 less performant than pure asynchronous code (although likely not by much)
\end_layout

\begin_layout Itemize
Wouldn't be able to handle large amounts of concurrent connections - i.e.
 doesn't solve the so-called 
\begin_inset Quotes eld
\end_inset

C10K problem
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "C10K"
literal "false"

\end_inset

.
\end_layout

\begin_layout Paragraph

\family typewriter
rocket
\end_layout

\begin_layout Standard
Rocket is 
\begin_inset Quotes eld
\end_inset

a web framework for Rust that makes it simple to write fast, secure web
 applications without sacrificing flexibility, usability, or type safety
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "RocketRs"
literal "false"

\end_inset

.
 Unlike any of the other libraries discussed thus far, 
\family typewriter
rocket
\family default
 is an actual web 
\emph on
framework
\emph default
 - its companion library 
\family typewriter
rocket_contrib
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "RocketContribDocs"
literal "false"

\end_inset

 provides support for commonly needed features, such as JSON support, static
 file serving, templating, and database pools; out of these three libraries
 considered, 
\family typewriter
rocket
\family default
 has the greatest amount of built-in functionality.
\end_layout

\begin_layout Subparagraph
Advantages
\end_layout

\begin_layout Itemize
Very easy to use: 
\family typewriter
rocket
\family default
's procedural macros and type safety make writing request handlers as easy
 as simply writing a Rust function and decorating it with, e.g.
 
\family typewriter
#[get(
\begin_inset Quotes eld
\end_inset

/route
\begin_inset Quotes erd
\end_inset

)]
\family default
 to signify how it should be accessible in the context of the application.
\end_layout

\begin_deeper
\begin_layout Itemize
This is in contrast to other non-macro-enabled web frameworks, which require
 a lot more boilerplate.
\end_layout

\end_deeper
\begin_layout Itemize
Built-in support for database connections, cookies, templating, and serializatio
n - i.e.
 most of the standard tools required to build a web application are built
 into 
\family typewriter
rocket
\family default
 or 
\family typewriter
rocket_contrib
\family default
 and integrate with the rest of the framework
\end_layout

\begin_layout Itemize
Synchronous programming model that's easy to reason about and far more ergonomic
 than asynchronous futures
\end_layout

\begin_layout Itemize
Security considerations are built into the framework, with functionality
 such as request guards and string validation/sanitizing (via the 
\family typewriter
RawStr
\family default
 type).
\end_layout

\begin_layout Subparagraph
Disadvantages
\end_layout

\begin_layout Itemize
As with 
\family typewriter
rouille
\family default
, probably slightly less performant than pure asynchronous code.
\end_layout

\begin_layout Itemize
As with 
\family typewriter
rouille
\family default
, also potentially vulnerable to the C10k problem.
\end_layout

\begin_layout Itemize
Using a big web framework means committing to that web framework's way of
 doing things; if the framework doesn't provide a way to do something, or
 to add on an extension to make something possible, it cannot be done!
\end_layout

\begin_deeper
\begin_layout Itemize
That said, 
\family typewriter
rocket
\family default
 does have good support for attaching custom modules (called 'fairings')
 to provide add-on pieces of functionality.
\end_layout

\end_deeper
\begin_layout Itemize
Rocket requires the use of nightly Rust, making maintaining a Rocket app
 harder: the Rust nightly toolchain must always be updated in lockstep with
 the version of Rocket, as changes in the nightly Rust compiler mandate
 changes in Rocket
\end_layout

\begin_layout Paragraph
Evaluation
\end_layout

\begin_layout Standard
As previously discussed, it seems as if using any asynchronous library would
 be the wrong choice for this project; while asynchronous programming can
 squeeze out extra performance and handle vast amounts of concurrent connections
, synchronous frameworks still manage to perform very well using plain OS
 threads, while making things vastly easier for the developer to reason
 about.
 Therefore, 
\family typewriter
hyper
\family default
 was ruled out as a choice for this project, as well as any other asynchronous
 Rust libraries.
\end_layout

\begin_layout Standard
As also previously discussed, it is also advantageous to focus on implementing
 the core 'business logic' of the server-side component; while smaller microfram
eworks like 
\family typewriter
rouille
\family default
 may result in a small increase in portability (e.g.
 greater ease of moving between libraries), the time that would be spent
 writing boilerplate code to get them working is time that could, and arguably
 should, be concentrated on the graph-search implementation, and other applicati
on-specific logic.
 A large web framework, like 
\family typewriter
rocket
\family default
, which reduces boilerplate and makes it easy to concentrate on this logic
 (handling all of the web-related tasks as much as possible), is therefore
 the best choice for this project - and, indeed, 
\family typewriter
rocket
\family default
 seems to be the most eminent framework of this class available in the Rust
 ecosystem, with over 186 thousand downloads at the time of writing.
 Although choosing 
\family typewriter
rocket
\family default
 might make longer-term maintenance of the project 
\emph on
slightly
\emph default
 harder, due to its dependency on nightly Rust and simply as it's an opinionated
 web framework (meaning your code becomes highly dependent on using that
 framework and no other one), this is not that much of an issue; since the
 application is mostly focused on implementing an API (a fairly straightforward
 task in any framework), it should be simple to port it to other web frameworks
 in the future, if the need arises.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsubsection
ORMs / databases
\end_layout

\begin_layout Subsubsection
API specification
\end_layout

\begin_layout Subsection
Map tiles
\end_layout

\begin_layout Subsection
Building a navigation graph
\end_layout

\begin_layout Subsection
Turn-by-turn navigation UI
\end_layout

\begin_layout Subsection
Starting navigation and place search
\end_layout

\begin_layout Section
Evaluation
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "references"
options "bibtotoc,plain"

\end_inset


\end_layout

\end_body
\end_document
